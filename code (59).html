<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive English Learning - Dictation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f4f7f6;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: #333;
        }
        .container {
            background-color: #fff;
            padding: 30px 35px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
            width: 90%;
            max-width: 750px;
            text-align: center;
        }
        h1 {
            color: #2a3b4c;
            margin-bottom: 20px; /* Adjusted margin */
            font-size: 26px;
            font-weight: 600;
        }
        #problem-selector-container {
            margin-bottom: 25px;
        }
        #problem-selector {
            padding: 10px 15px;
            font-size: 16px;
            border-radius: 6px;
            border: 1px solid #ccc;
            min-width: 250px;
            cursor: pointer;
        }
        #sentence-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: baseline;
            margin-bottom: 30px;
            padding: 10px 5px;
            min-height: 100px; /* Ensure some height even when empty */
            line-height: 2.2;
            text-align: left;
            font-size: 19px;
            color: #444;
            border: 1px dashed #e0e0e0; /* Light border to indicate text area */
            border-radius: 6px;
        }
        .char-span {
            display: inline-block;
            text-align: center;
            margin: 0 0.5px;
            padding: 0 1px;
            transition: color 0.2s ease-out, background-color 0.2s, border-color 0.2s;
        }
        .char-span.letter-char {
            color: #777;
            min-width: 10px;
            font-weight: 600;
            border-bottom: 2px solid transparent;
        }
        .char-span.is-space {
            min-width: 6px;
            display: inline;
        }
        .char-span.current.letter-char {
            background-color: #e0f2fe;
            border-bottom: 2px solid #0ea5e9;
            color: #555;
            border-radius: 3px;
            animation: blinkCursorBorder 1.2s infinite ease-in-out;
        }
        @keyframes blinkCursorBorder {
            0%, 100% { border-bottom-color: #0ea5e9; }
            50% { border-bottom-color: #7dd3fc; }
        }
        .char-span.correct.letter-char {
            color: #2c3e50;
            font-weight: 600;
            background-color: transparent;
            border-bottom-color: transparent;
        }
        .feedback {
            margin-top: 20px;
            font-size: 17px;
            height: 28px;
            font-weight: 500;
        }
        .feedback.error { color: #ef4444; }
        .feedback.success { color: #22c55e; font-weight: 600; }
        #initial-message { font-style: italic; color: #666; }
        #reset-button {
            margin-top: 30px;
            padding: 12px 30px;
            font-size: 16px;
            color: #fff;
            background-color: #0ea5e9;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.25s ease;
            font-weight: 500;
        }
        #reset-button:hover { background-color: #0284c7; }
        #reset-button:disabled { background-color: #94a3b8; cursor: not-allowed; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Typing Dictation Practice</h1>

        <div id="problem-selector-container">
            <select id="problem-selector">
                <option value="">-- Select a Problem --</option>
            </select>
        </div>

        <div id="sentence-container">
            <p id="initial-message">Please select a problem from the dropdown above to start.</p>
        </div>
        <div id="feedback-message" class="feedback"></div>
        <button id="reset-button" style="display:none;">Try Again</button>
    </div>

    <script>
        // Define your problem files here
        // 'name' is what displayed in the dropdown, 'path' is the actual file name
        const problemFiles = [
            { name: "Dictionary Text (Default)", path: "default_english_text.txt" },
            { name: "Sample Problem 1", path: "problem1.txt" },
            { name: "Sample Problem 2", path: "problem2.txt" },
            // Add more problems here as needed:
            // { name: "My Custom Problem", path: "my_custom_problem.txt" },
        ];

        const sentenceContainer = document.getElementById('sentence-container');
        const feedbackMessage = document.getElementById('feedback-message');
        const resetButton = document.getElementById('reset-button');
        const problemSelector = document.getElementById('problem-selector');
        const initialMessage = document.getElementById('initial-message');

        let sourceText = ""; // Will be loaded from file
        let charSpans = [];
        let currentIndex = 0;
        let gameActive = false;

        function populateProblemSelector() {
            problemFiles.forEach(file => {
                const option = document.createElement('option');
                option.value = file.path;
                option.textContent = file.name;
                problemSelector.appendChild(option);
            });
        }

        async function loadProblem(filePath) {
            if (!filePath) {
                sourceText = "";
                initGame(); // This will show the initial message
                return;
            }
            try {
                const response = await fetch(filePath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} - Could not load ${filePath}`);
                }
                const text = await response.text();
                sourceText = text.trim(); // Trim whitespace from loaded text
                initGame();
            } catch (error) {
                console.error("Error loading problem:", error);
                sentenceContainer.innerHTML = `<p style="color:red;">Error: Could not load the problem file. Make sure '${filePath}' exists in the same directory and you are using a local web server.</p>`;
                feedbackMessage.textContent = '';
                resetButton.style.display = 'none';
                gameActive = false;
                document.removeEventListener('keydown', handleKeydown);
            }
        }

        function initGame() {
            sentenceContainer.innerHTML = ''; // Clear previous content, including initial message or error
            charSpans = [];
            currentIndex = 0;
            
            if (!sourceText) {
                sentenceContainer.innerHTML = '<p id="initial-message">Please select a problem from the dropdown above to start.</p>';
                feedbackMessage.textContent = '';
                resetButton.style.display = 'none';
                gameActive = false;
                document.removeEventListener('keydown', handleKeydown);
                return;
            }
            
            gameActive = true;

            sourceText.split('').forEach(originalChar => {
                const span = document.createElement('span');
                span.classList.add('char-span');
                span.dataset.original = originalChar;

                if (originalChar === ' ') {
                    span.innerHTML = '&nbsp;';
                    span.classList.add('is-space');
                } else {
                    span.textContent = '_';
                    span.classList.add('letter-char');
                }
                sentenceContainer.appendChild(span);
                charSpans.push(span);
            });

            feedbackMessage.textContent = '';
            feedbackMessage.className = 'feedback';
            resetButton.style.display = 'none'; // Hide reset button until game ends
            resetButton.disabled = true;

            document.removeEventListener('keydown', handleKeydown);
            document.addEventListener('keydown', handleKeydown);
            
            advanceToNextTypableCharacter();
        }

        function advanceToNextTypableCharacter() {
            if (currentIndex > 0 && currentIndex <= sourceText.length) {
                 if(charSpans[currentIndex-1]) charSpans[currentIndex-1].classList.remove('current');
            }
            
            while (currentIndex < sourceText.length && charSpans[currentIndex].dataset.original === ' ') {
                const spaceSpan = charSpans[currentIndex];
                spaceSpan.classList.add('correct');
                currentIndex++;
            }

            if (currentIndex < sourceText.length) {
                charSpans[currentIndex].classList.add('current');
            } else if (gameActive) { // All characters processed
                completeGame();
            }
        }
        
        function completeGame() {
            if (!gameActive) return;
            gameActive = false;

            // Clean up 'current' from last char if any
            if(currentIndex > 0 && charSpans[currentIndex-1]) {
                 charSpans[currentIndex-1].classList.remove('current');
            }
             // If completion was due to trailing spaces, current might point beyond array
            if(currentIndex < sourceText.length && charSpans[currentIndex]) {
                charSpans[currentIndex].classList.remove('current');
            }


            feedbackMessage.textContent = 'Congratulations! You completed it!';
            feedbackMessage.className = 'feedback success';
            gsap.fromTo(feedbackMessage, { opacity: 0, y: 10 }, { opacity: 1, y: 0, duration: 0.4, ease: "power2.out" });
            
            resetButton.style.display = 'inline-block';
            resetButton.disabled = false;
            gsap.fromTo(resetButton, {opacity:0, scale:0.9}, {opacity:1, scale:1, duration:0.3, delay:0.1, ease: "back.out(1.7)"});
            document.removeEventListener('keydown', handleKeydown);
        }

        function handleKeydown(event) {
            if (!gameActive || currentIndex >= sourceText.length) return;
            if (event.metaKey || event.ctrlKey || event.altKey) return;

            const currentSpan = charSpans[currentIndex];
            // This check is mostly a safeguard; advanceToNextTypableCharacter should handle spaces.
            if (!currentSpan || currentSpan.dataset.original === ' ') {
                advanceToNextTypableCharacter();
                if (!gameActive || currentIndex >= sourceText.length) return; 
            }

            const typedKey = event.key;

            if (typedKey.length === 1 && typedKey !== ' ') {
                event.preventDefault(); 

                const expectedChar = charSpans[currentIndex].dataset.original;

                if (typedKey === expectedChar) {
                    const spanToCorrect = charSpans[currentIndex];
                    spanToCorrect.classList.remove('current');
                    spanToCorrect.classList.add('correct');
                    spanToCorrect.textContent = expectedChar;

                    gsap.fromTo(spanToCorrect, 
                        { scaleY: 1.3, scaleX: 1.1, opacity: 0.7 }, 
                        { scaleY: 1, scaleX: 1, opacity: 1, duration: 0.3, ease: "elastic.out(1, 0.6)" }
                    );

                    feedbackMessage.textContent = '';
                    feedbackMessage.className = 'feedback';
                    
                    currentIndex++;
                    advanceToNextTypableCharacter();

                } else {
                    feedbackMessage.textContent = 'Incorrect. Try again.';
                    feedbackMessage.className = 'feedback error';
                    gsap.fromTo(feedbackMessage, {opacity:0}, {opacity:1, duration:0.2});

                    const targetSpan = charSpans[currentIndex];
                    gsap.to(targetSpan, { 
                        x: '+=2', yoyo: true, repeat: 3, duration: 0.06, 
                        ease: 'power1.inOut',
                        onComplete: () => gsap.set(targetSpan, {clearProps: "x"}) 
                    });
                    gsap.to(targetSpan, {
                        backgroundColor: '#fee2e2', duration: 0.1, yoyo: true, repeat: 1,
                        onComplete: () => {
                            if(targetSpan.classList.contains('current')) {
                                targetSpan.style.backgroundColor = '#e0f2fe';
                            } else {
                                targetSpan.style.backgroundColor = '';
                            }
                        }
                    });
                }
            } else if (typedKey === ' ' && charSpans[currentIndex].dataset.original !== ' ') {
                event.preventDefault();
                feedbackMessage.textContent = 'Incorrect. A letter or punctuation was expected.';
                feedbackMessage.className = 'feedback error';
                gsap.fromTo(feedbackMessage, {opacity:0}, {opacity:1, duration:0.2});
                const targetSpan = charSpans[currentIndex];
                gsap.to(targetSpan, { 
                    x: '+=2', yoyo: true, repeat: 3, duration: 0.06, ease: 'power1.inOut',
                    onComplete: () => gsap.set(targetSpan, {clearProps: "x"}) 
                });
            }
        }

        problemSelector.addEventListener('change', (event) => {
            loadProblem(event.target.value);
        });

        resetButton.addEventListener('click', () => {
            // Re-initialize the game with the currently selected problem (or last loaded sourceText)
            // This allows "Try Again" for the same problem.
            initGame();
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            populateProblemSelector();
            // initGame(); // Don't start game immediately, wait for selection
        });
    </script>
</body>
</html>